
# 概念

尾递归就是操作的最后一步是调用自身的递归

```java
function f(x){
  return g(x);
}

以下两种情况，都不属于尾调用。
```
// 情况一
function f(x){
  let y = g(x);
  return y;
}

// 情况二
function f(x){
  return g(x) + 1;
}
情况一是调用函数g之后，还有别的操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。

尾调用不一定出现在函数尾部，只要是最后一步操作即可。
```java
function f(x) {
  if (x > 0) {
    return m(x)
  }
  return n(x);
}

```
```java
```

## 优点

尾递归和一般的递归不同在对内存的占用，普通递归创建stack累积而后计算收缩，尾递归只会占用恒量的内存（和迭代一样）。

因为进入最后一步后不再需要参考外层函数（caller）的信息，因此 **没必要保存外层函数的stack**，递归需要用的stack只有目前这层函数的，因此 **避免了栈溢出风险**。

## java中的尾递归

尾递归依赖的是编译器对尾递归写法的优化,java8并没有实现,可以使用lambda的懒加载(惰性求值)机制来延迟递归的调用，从而实现栈帧的复用。

http://www.jb51.net/article/126839.htm















#
