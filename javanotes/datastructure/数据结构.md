# 线性结构和非线性结构

线性结构：	线性表
		  		顺序存储：顺序表
		  					顺序表用一组地址连续的存储单元，依次存储线性表中的数据元素特点是表中元素逻辑顺序和物理顺序相同，可以进行**随机访问特性**，但插入和删除需要移动大量元素
		  		链式存储：
		  			单链表 只有一个指向其后继的指针，单链表只能从头结点依次顺序地向后遍历。若要访问某个节点的前驱结点，只能从头开始遍历访问后继结点的时间复杂度为O(1),访问前驱结点的时间复杂度为O(n)	 (指针实现)
		  			双链表	有两个指针，分别指向其前驱结点和后继结点 (指针实现)
		  			循环列表 循环单链表和单链表的区别在于表中的最后一个结点的指针不是NULL，而是指向头结点 循环双链表头指针还要指向表尾结点 (指针实现)
		  			静态列表 (借助数组实现)
		  	串
		  	栈
		  	队列
非线性结构：树	满二叉树，高度为h，含有2的h次方-1
			图
			集合

## 顺序表和链表的比较

顺序存储
	优点：
		1.方法简单，各种高级语言中都有数组类型，容易实现。
		2.不用为表示节点间的逻辑关系而增加额外的存储开销。逻辑相邻与物理相邻一致。
		3.顺序表具有按元素序号随机访问的特点。顺序表中按序号访问Ai的时间复杂度为O(1)，而链表按序号访问的时间复杂度为O(n)，所以如果经常做的运算是按序号访问数据元素，显然顺序表优于链表。
	缺点：
		1.顺序表中做插入，删除操作是，平均移动大约为表中元素的一半，对n较大的顺序表插入，删除的效率低。
		2.需要预先分配足够大的存储空间，估计过大，可能导致浪费，预先分配过小又会导致溢出。
链式存储
	优点：
		1.顺序表中插入删除方便，不需要多次移动元素。
		2.不需要预先分配足够大的存储空间
	缺点：
		1.需要为存储结点间的逻辑关系而增加额外的存储开销。存储密度低，存储密度是指一个结点中数据元素所占的存储单元和整个结点所占的存储单元之比，显然链式存储结构的存储密度是小于1的。
		2.链表不具有按元素序号随机访问的特点。

# 链表

## 链表有环问题

### 判断链表是否有环

在头结点设定两个指针slow fast，一个一次走1步，一个一次走两步，若两个指针相遇则链表有环

为什么两个指针相遇是slow指针还没有走完链表？
因为假设环长为n，slow指针已经到达环的入口处，起点距离环入口为k，则fast离环入口k mod n处,假设k mod n等于d，假设他们在x秒相遇，则slow走了x步，fast走了2x+d步，相遇时fast超slow至少一圈(有可能在slow未进入环中时，fast就已经在环中走了几圈了),即(2x+d)-x=n，即x+d=n，即x<=n(d=0的情况下，即在环中两个指针同时从环入口开始走)，所以说slow相遇前肯定没有走完链表

### 环入口

头指针到入口点的距离等于slow fast指针相遇点到入口的距离
	假设走了s秒，则 2s=s+n*r，n为fast多走的环的圈数，r为环长度
	s=n*r，假设链表长度为L，起点到入口的距离为a，相遇点到入口的距离为x
	```
    a+x=s(a+x即slow指针走的距离) a+x=n*r
	a+x=(n-1)*r+(L-a)
	a=(n-1)*r+(L-a-x)
    ```
	这说明从头结点到入口的距离，等于转了(n-1)圈以后，相遇点到入口的距离。
	然后就可以用两个指针分别从头结点和相遇点开始移动，每次两个指针移动一个距离，相遇时即为环入口


假设p，q两个指针速度分别为1,2。因为相遇时p没有走完一圈，q的位置为(k+2i) mod n,0<k<n(?)。那么i=(2i+k)(mod n)
(i+k) mod n = 0 当i=n-k时，p，q相遇，即头指针到入口点的距离等于slow fast指针相遇点到入口的距离

ela：起点到入口的距离为a，r为环长度，a<r时
要想两者相遇，fast则需要比slow多走r-(a mod r)的距离，又a<r,即多走r-a的距离，那么slow也走了r-a的距离，即相遇点距离入口处的距离为r-(r-a)=a的距离，也就是头指针到入口点的距离等于slow fast指针相遇点到入口的距离


### 环长

第一次相遇后继续走，第二次相遇slow走过的长度就是环的长度

### 链表长度







## 栈的应用

1.数值转换
	例如10进制转换为2进制的时候，将得到的2进制数进栈保存，转换完后依次出栈。
2.括号的匹配
	将一串字符串输入时，如果遇到对称符号的左边部分，则将其压入栈中，当遇到对称符号的右边部分，则弹出栈中的一个对象，实现比对，如果是对称的，则说明当前的符号是平衡的，如果不对称，则说明当前字符串是不平衡的，当字符串读完以后，如果所有的符号都是平衡的，栈中此时应该就是为空，通过判断栈中是否为空，说明字符串是否是符号平衡的。
3.计算后缀表达式
	先将中锥表达式转换为后缀表达式，只用一个对象栈，从左往右扫描表达式，每遇到一个操作数就送入到栈中保存，每遇到一个运算符就从栈中取出两个操作数进行当前操作，然后把结果入栈，直到整个表达式结束。

# 队列

当队列为空时enqueue时头结点也要指向新添的元素

## 队列的引用


1.层次遍历二叉树
	访问根结点，
	若该结点的左，右孩子非空，则将该元素所指结点的左右孩子入队，
	不断进行，当队列为空时，二叉树的层次遍历结束。


# 树

## 哈夫曼树



# 排序

## 选择排序

首先找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换)。再次，再剩下的元素中找到最小的元素，将它与数组第二个元素交换位置。如此反复直到将整个数组排序。

交换的总次数为N

### 特点

1.运行时间和输入无关
	为了找出最小的元素而扫描一遍数组并不能为下一次扫描提供信息
2.数组移动是最小的。交换次数和数组大小是线性关系。

## 插入排序

### 特点

与选择排序相比，左端已排好序的元素可能需要被移动

插入排序所需时间取决于输入中元素的初始顺序，对其中的元素已经接近有序的数组进行排序速度很快。

## 希尔排序

**是一种基于插入排序的快速排序算法，插入排序对大规模乱序数组排序很慢**，因为它只会交换相邻元素（插入排序相当于把已经拍好序的元素的右边的元素先与其左边的第一个元素相比，如果小于它，那么两个元素交换位置，这样一直比较交换直到有序，算法中虽然是先用这个元素和有序的序列比较然后直接插入到合适的位置，但因为最终元素都需要移动所以这样想是等价的），所以元素只能一点一点从数组一端移动到另一端，例如如果主键最小的元素正好在数组的尽头，要将它挪到正确的位置则需要N-1次移动。

当步长h很大时，可以将元素一次移动到很远的地方，希尔排序更高效的原因是权衡了子数组的规模和有效性，排序之初，各个子数组都很短，排序之后的子数组都是部分有序的，这两种情况都很适合插入排序。

对任意排序的数组的表现也很好

## 归并排序

## 快速排序

空间复杂度为log2^n 因为要为两端指针分配空间

## 堆排序

## 插入元素

将新元素加到数组末尾，然后上浮到合适的位置

## 删除**最大**元素

从数组顶端删除最大元素，并将数组的最后一个元素放到顶端，减小堆的大小并将这个元素下沉到合适的位置

### 堆的构造

可以使用从左至右遍历数组的方法，用swim()方法保证扫描指针左侧的所有元素已经是一颗堆有序的完全树即可。

更高效的方法是从右至左用sink()函数构造子堆。(数组最右边都是堆的叶子节点，相当于一个子堆的根节点)数组的每个位置都已经是一个子堆的根节点了，sink()对于这些子堆也适用，如果一个结点的两个子结点都已经是堆了，那么在该结点上调用sink()可以将他们变成一个堆，**这个过程中会递归的建立起堆的秩序**(先处理的是大小为3的堆，使所有大小为3的堆有序后处理大小为7的堆的时候它的两个大小为3的子堆已经是有序的了，所以只要对根结点进行一次下沉就可以构建好堆)，同时开始时只需要扫描数组中的一半元素，因为我们可以跳过大小为1的子堆

### 下沉排序

堆构造完成后，用下沉排序进行堆排序，即将最大的元素与未排序的堆中的最后一个元素交换位置，然后对交换上来的元素进行下沉排序，使其到达合适的位置。
