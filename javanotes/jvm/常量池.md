# 常量池

Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。

## 静态常量池

即*.class文件中的常量池,主要存放字面量(Literal)和符号引用(Symbolic References)

* 字面量
    * 文本字符串
    * 声明为final的常量
    * 其他
* 符号引用(编译原理方面的概念)
    * 类和接口的全限定名(Full Qualified Name)
    * 字段的名称和描述符(Descriptor)
    * 方法的名称和描述符

### 静态常量池细节

* 常量池入口为一个u2类型的数据,代表常量池容量计数值(从1开始)
    将第0项空出来是为了满足后面某些指向常量池的索引值得数据在特定情况下需要表达"不引用任何一个常量池项目的含义"
* 每一项常量都是一个表
    * 第一位是个u1类型的标志位,代表常量类型
    * 1.7之前有11种结构不同的表结构数据,之后额外加了3种


### 静态常量池中的表

#### CONSTANT_Utf8_info

其中length为u2,能表达的最大值为65535,而Class文件中方法,字段都需要引用CONSTANT_Utf8_info来描述名称,所以java程序中定义超过64KB的变量或方法名,则会无法编译.

## 运行时常量池

方法区的一部分

jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。

### 例子

```java
String s1 = "Hello";
String s2 = "Hello";
String s3 = "Hel" + "lo";
String s4 = "Hel" + new String("lo");
String s5 = new String("Hello");
String s6 = s5.intern();
String s7 = "H";
String s8 = "ello";
String s9 = s7 + s8;

System.out.println(s1 == s2);  // true
System.out.println(s1 == s3);  // true
System.out.println(s1 == s4);  // false
System.out.println(s1 == s9);  // false
System.out.println(s4 == s5);  // false
System.out.println(s1 == s6);  // true
```

s1 == s2这个非常好理解，s1、s2在赋值时，均使用的字符串字面量，说白话点，就是直接把字符串写死，在编译期间，这种字面量会直接放入class文件的常量池中，从而实现复用，载入运行时常量池后，s1、s2指向的是同一个内存地址，所以相等。

s1 == s3这个地方有个坑，s3虽然是动态拼接出来的字符串，但是所有参与拼接的部分都是已知的字面量，在编译期间，这种拼接会被优化，编译器直接帮你拼好，因此String s3 = "Hel" + "lo";在class文件中被优化成String s3 = "Hello";，所以s1 == s3成立。

s1 == s4当然不相等，s4虽然也是拼接出来的，但new String("lo")这部分不是已知字面量，是一个不可预料的部分，编译器不会优化，必须等到运行时才可以确定结果，结合字符串不变定理，鬼知道s4被分配到哪去了，所以地址肯定不同。配上一张简图理清思路：

s1 == s9也不相等，道理差不多，虽然s7、s8在赋值的时候使用的字符串字面量，但是拼接成s9的时候，s7、s8作为两个变量，都是不可预料的，编译器毕竟是编译器，不可能当解释器用，所以不做优化，等到运行时，s7、s8拼接成的新字符串，在堆中地址不确定，不可能与方法区常量池中的s1地址相同。

s4 == s5已经不用解释了，绝对不相等，二者都在堆中，但地址不同。

s1 == s6这两个相等完全归功于intern方法，s5在堆中，内容为Hello ，intern方法会尝试将Hello字符串添加到常量池中，并返回其在常量池中的地址，因为常量池中已经有了Hello字符串，所以intern方法直接返回地址；而s1在编译期就已经指向常量池了，因此s1和s6指向同一地址，相等。




































#
