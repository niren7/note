
# 内存布局

![对象的内存布局](pic/对象的内存布局.png)

* 对象头(Header)
    * 运行时数据(Mark Word)(对应`mark`字段)
    * 类型指针(对应`-klass`字段,指向该对象的运行时类的 Klass 内部对象的指针)
    * length(对象为数组时存在)
* 实例数据(Instance Data)
* 对齐填充(Padding)(不是必然存在的)

# 对象头

## 运行时数据(官方称为Mark Word)

包括哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。

因为对象头信息是与对象自身定义的数据无关的 **额外存储成本**,考虑到虚拟机的空间效率,Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据自己的状态复用自己的存储空间

在32位系统占4字节，在64位系统中占8字节,如果开启压缩指针，那么为4字节；

## 类型指针

指向对象对应的类元数据的指针。

并不是所有的虚拟机的实现都必须在对象数据上保留类型指针,换句话说,查找对象的元数据信息并不一定要经过对象本身.

在32位系统占4字节，在64位系统中占8字节；

对应`_klass`字段,一个指向该对象的运行时类的 Klass 内部对象的指针.这个 Klass 内部对象是HotSpot VM内部用来记录类的元数据的内部对象，并不对Java程序直接暴露出来。在这个上下文里，它里面有两个有趣的东西：一个是 `_java_mirror` 字段，指向该类对应的 java.lang.Class 对象；另一个是 prototype_header ，记录着该类的所有实例都会拥有的某些初始状态。

## length

保存数组长度的空间

数组对象特有,因为虚拟机可以通过元数据信息确定java对象的大小,但是从数组的元数据中不能确定数组对象的大小

32位的JVM上，该区域的长度为32bit，在64位未开启压缩指针的JVM中，这部分数据的长度为64bit，否则为32bit

# 实例数据

对象真正存储的有效信息

也是在程序代码中所定义的各种类型的字段内容。无论是从父类中继承下来的，还是在子类中定义的，都需要记录下来。

HotSpot虚拟机默认的分配策略如下所示。

* doubles & longs
* ints & floats
* shorts & chars
* booleans & bytes
* references

可以看出，相同宽度的字段总是被分配到一起，并且在满足这个条件的前提下，在 **父类中定义的字段会出现在子类字段之前**。

在类继承的边界上如果有因对齐而带来的空隙的话，可以把子类的字段拉到空隙里。这种排布方式可以让原始类型字段最大限度地紧凑排布在一起，减少字段间因为对齐而带来的空隙；
同时又让引用类型字段尽可能排布在一起，**减少OopMap的开销**。

byte和boolean是1个字节，short和char是2个字节，int和float是4个字节，long和double是8个字节，reference是4个字节（64位系统中是8个字节）。



# 对齐填充

HotSpot虚拟机要求对象的起始地址必须是8字节的整数倍，也就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐的时候，就需要通过对齐填充来补全。































#
