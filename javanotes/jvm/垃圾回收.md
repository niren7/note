
# 判断对象是否还存活

* 引用计数法
    * 难以解决对象之间相互引用的问题
* 可达性分析

# 垃圾回收算法

* 标记-清除算法
* 复制算法
* 标记-整理算法

# 新生代采用复制算法

将内存划为一块较大的Eden空间和两块较小的Survivor空间,比例为8:1:1

回收时把Eden和Survivor中存活的对象一次性复制到另外一块未使用的Survivor空间上

当Survivor空间不够用时,需要依赖其他内存(这里指老年代)进行分配担保

# 老年代采用的垃圾回收算法

标记-清除算法和标记-整理算法

因为对象存活率高和没有额外空间对它进行分配担保.

# 内存分配和回收策略

* 对象优先在Eden区分配
    * 当Eden空间不足时,虚拟机将发起一次Minor GC
* 大对象直接进入老年代
    * 大对象指需要大量连续内存空间的Java对象,典型的有很长的字符串和数组
    * 有参数可设置大于该值得对象直接在老年代分配,这是为了避免Eden区和两个Survior区之间发生大量的内存复制
* 长期存活的对象将进入老年代
    * 对象每经历一次Minor GC, 年龄就增加1,可通过参数设置晋升老年代的年龄阀值
* 动态对象年龄判定
    * Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半,年龄大于或等于该对象年龄的对象就可以直接进入老年代






#
