# 生命周期

![类加载生命周期](pic/类加载生命周期.png)

验证，准备，解析3个部分统称连接

加载，验证，准备，初始化,卸载 这5个阶段的顺序是确定的.

类加载的过程必须按照这种顺序 **开始**,因为这些阶段通常是互相交叉混合地运行的,会在一个阶段执行的过程中调用,激活另外一个阶段.

解析阶段某些情况下可以在初始化阶段之后再开始,这是为了支持java语言的运行时绑定(也称动态绑定或晚期绑定)

# 有且只有5种情况必须立即执行初始化阶段

* 遇到new,getstatic,putstatic,invokestatic这4条字节码,如果类没有初始化,则需要先触发其初始化
    * 常见的java代码场景
        * 使用new关键字实例化对象
        * 访问或者设置一个类的静态字段（被final修饰、编译器优化时已经放入常量池的例外）
        * 调用类方法
* 初始化类的时候，如果其父类没有被初始化过，则要先触发其父类初始化。
* 使用java.lang.reflect包的方法进行反射调用的时候，如果类没有被初始化，则要先初始化。
* 虚拟机启动时,用户要指定一个要执行的主类(包含main方法)，用户会先初始化这个主类
* jdk 1.7后，如果java.lang.invoke.MethodHandle的实例最后对应的解析结果是 REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄，并且这个方法所在类没有初始化，则先初始化。

## 主动引用和被动引用

上面5种行为称为对一个类进行主动引用,除此之外所有引用类的方式都不会触发初始化,称为被动引用(例子见深入理解java虚拟机)


# 类加载过程

## 加载

加载过程主要完成三件事情：

* 通过类的全限定名来获取定义此类的二进制字节流
* 将这个类字节流代表的静态存储结构转为方法区的运行时数据结构
* 在内存中生成一个代表此类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

通过类的全限定名来获取定义此类的二进制字节流没有指定要从Class文件获取,准确的说是没有指明要从哪里获取,怎样获取,许多的java技术都建立在这一基础上:
* 从 ZIP 包中读取，这很常见，最终成为日后 JAR、 EAR、 WAR 格式的基础。
* 从网络中获取，这种场景最典型的应用就是 Applet。
* 运行时计算生成，这种场景使用得最多的就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为*$Proxy 的代理类的二进制字节流。
* 由其他文件生成，典型场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。
* 从数据库中读取。
* .....

相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器区完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式（即重写一个类加载器的loadClass()方法）。

对于数组类而言，数组类本身不通过类加载器创建，它是由JVM直接创建的。但数组类与类加载器任然有很密切的关系，因为数组类的元素类型最终是要靠类加载器去创建

数组类(下面简称为C)的创建过程遵循的规则

* 如果数组的组件类型（ Component Type， 指的是数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组 C 将在加载该组件类型的类加载器的类名称空间上被标识（这点很重要，在 7. 4 节会介绍到，一个类必须与类加载器一起确定唯一性）。
* 如果数组的组件类型不是引用类型（例如 int[] 数组）， Java 虚拟机将会把数组 C 标记为与引导类加载器关联。
* 数组类的可见性与它的组件可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认设置为public

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区怎么存储由JVM自己定义。然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是在Java堆中，对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面）。

## 验证

验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

验证阶段大致上会完成下面 4 个阶段的检验动作：

* 文件格式验证
* 元数据验证
* 字节码验证
* 符号引用验证

下面4个具体验证点见虚拟机规范

### 文件格式验证

第一阶段要验证字节流是否符合 Class 文件格式的规范

### 元数据验证

第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。

### 字节码验证

主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。

### 符号引用验证

最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段—---—解析阶段中发生。

## 准备

准备阶段是正式为 **类变量** 分配内存并设置类变量初始值的阶段,这些变量所使用的内存都将在 **方法区** 中进行分配

这个阶段进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值。

`public static int value=123;`

变量value在准备阶段过后的初始值为0而不是123,因为这时候尚未开始执行任何java方法,而把value赋值为123的putstatic指令是程序被编译后,存放于类构造器<clinit>方法中的,所以把 value 赋值为 123 的动作将在初始化阶段(方法中)才会执行。

特殊情况：如果类字段的字段属性表中存在 ConstantValue 属性，那在准备阶段变量 value 就会被初始化为 ConstantValue 属性所指定的值，假设上面类变量 value 的定义变为

`public static final int value= 123；`

编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 123。

## 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

解析动作主要针对类或接口、字段解析、类方法解析、接口方法解析、方法类型解析、方法句柄解析和调用点限定符 7 类符号引用进行。详细见深入理解java虚拟机

符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在Java中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。

直接引用可以是
（1）直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）
（2）相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）
（3）一个能间接定位到目标的句柄
直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。

## 初始化

初始化阶段是执行类构造器<clinit>方法的过程。稍后介绍它是怎么生成的，这里我们先看一下<clinit>方法执行过程中一些可能会影响程序运行行为的特点和细节，这部分相对更贴近于普通的程序开发人员。

* <clinit>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的,静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。
* 虚拟机保证子类的<clinit>方法执行之前，父类的<clinit>方法已经执行完毕。
* 对于接口，不能使用static块，但是可以有静态变量的赋值操作。子类接口的<clinit>方法调用并不保证父接口的<clinit>方法被先调用，只有用到父接口的静态变量的时候，父接口<clinit>方法才会被调用。接口的实现类在初始化时也一样不会执行接口的<clinit>方法。
* 虚拟机会保证一个类的<clinit>方法在多线程环境中被正确地加锁、同步。如果一个线程的<clinit>方法调用时间过长，就可能造成多个线程阻塞。















#
