# 简单工厂

## 优点

1. 初始化实例时的工作放到工厂里进行，使代码 **更容易维护**.(初始化工作分散在各处的话要改的地方就很多)

2. 更符合面向对象的原则 & 面向接口编程，而不是面向实现编程。

## 缺点

1. 工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，**整个系统都会受到影响**；

2. **违背“开放 - 关闭原则”**，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。

3. 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。


# 工厂

## 优点：

1、更符合开-闭原则

新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可，而简单工厂模式需要修改工厂类的判断逻辑

2、符合单一职责原则

每个具体工厂类只负责创建对应的产品，而简单工厂中的工厂类存在复杂的switch逻辑判断

3、不使用静态工厂方法，可以形成基于继承的等级结构，而简单工厂模式的工厂类使用静态工厂方法

总结：工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。

## 缺点

1、添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；

2、由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。

3、虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；

4、一个具体工厂只能创建一种具体产品


# 抽象工厂

定义：抽象工厂模式，即Abstract Factory Pattern，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。

概括：

抽象工厂模式引入抽象产品族Abstract Product 的概念，它是所有产品的父类，其下是Product抽象类，它是Abstract Product的子类，是具体产品类的父类，可有多种不同类型，如ProductA 、Product B，再往下，是具体的产品类 Concrete ProductA 、Concrete ProductB；

Concrete Factory 有共同的父类Abstract Factory。每个具体的Concrete Factory都可以生产多种不同产品。如Factory 1 可以生产Concrete ProductA1、Concrete Product B1，Factory 2可以生产Concrete A2、Concrete B2。

总结：

多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。   
一个抽象工厂类，可以派生出多个具体工厂类。    每个具体工厂类可以创建多个具体产品类的实例。

## 优点

1. 降低耦合

抽象工厂模式将具体产品的创建延迟到具体工厂的子类中，这样将对象的创建封装起来，可以减少客户端与具体产品类之间的依赖，从而使系统耦合度低，这样更有利于后期的维护和扩展；

2. 更符合开-闭原则

新增一种产品类时，只需要增加相应的具体产品类和相应的工厂子类即可，而简单工厂模式需要修改工厂类的判断逻辑

3. 符合单一职责原则

4. 每个具体工厂类只负责创建对应的产品，而简单工厂中的工厂类存在复杂的switch逻辑判断

5. 不使用静态工厂方法，可以形成基于继承的等级结构，而简单工厂模式的工厂类使用静态工厂方法



## 缺点

抽象工厂模式很难支持新种类产品的变化。

这是因为抽象工厂接口中已经确定了可以被创建的产品集合，如果需要添加新产品，此时就必须去修改抽象工厂的接口，这样就涉及到抽象工厂类的以及所有子类的改变，这样也就违背了“开发——封闭”原则。
