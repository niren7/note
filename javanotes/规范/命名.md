[TOC]

* 抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以它要测试的类的名称开始，以Test结尾。
* POJO类中的任何布尔类型的变量，都不要加is，否则部分框架解析会引起序列化错误。 
  反例：定义为基本数据类型boolean isSuccess；的属性，它的方法也是isSuccess()，RPC框架在反向解析的时候，“以为”对应的属性名称是success，导致属性获取不到，进而抛出异常。
* 如果使用到了设计模式，建议在类名中体现出具体模式。
* 接口和实现类的命名有两套规则： 1）【强制】对于Service和DAO类，基于SOA的理念，暴露出来的服务一定是接口，内部的实现类用Impl的后缀与接口区别。 正例：CacheServiceImpl实现CacheService接口。 2） 【推荐】 如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able的形式）。 正例：AbstractTranslator实现 Translatable。


* 所有的相同类型的包装类对象之间值的比较，全部使用equals方法比较。
* 关于基本数据类型与包装数据类型的使用标准如下： 1） 【强制】所有的POJO类属性必须使用包装数据类型。 2） 【强制】RPC方法的返回值和参数必须使用包装数据类型。 3） 【推荐】所有的局部变量使用基本数据类型。 说明：POJO类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE问题，或者入库检查，都由使用者来保证。 正例：数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。 反例：比如显示成交总额涨跌情况，即正负x%，x为基本数据类型，调用的RPC服务，调用不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划线-。所以包装数据类型的null值，能够表示额外的信息，如：远程调用失败，异常退出。
* 【强制】定义DO/DTO/VO等POJO类时，不要设定任何属性默认值。 反例：POJO类的gmtCreate默认值为new Date();但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。

* 【推荐】防止NPE，是程序员的基本修养，注意NPE产生的场景： 1）返回类型为基本数据， 返回类型为基本数据， 返回类型为基本数据， 返回类型为基本数据， returnreturn returnreturn包装数据类型的对象时，自动拆箱有可能产生 包装数据类型的对象时，自动拆箱有可能产生 包装数据类型的对象时，自动拆箱有可能产生 包装数据类型的对象时，自动拆箱有可能产生 包装数据类型的对象时，自动拆箱有可能产生 包装数据类型的对象时，自动拆箱有可能产生 包装数据类型的对象时，自动拆箱有可能产生 包装数据类型的对象时，自动拆箱有可能产生 NPE 。 反例：public int f() { return Integer对象}， 如果为null，自动解箱抛NPE。 2） 数据库的查询结果可能为null。 3） 集合里的元素即使isNotEmpty，取出的数据元素也可能为null。 4） 远程调用返回对象时，一律要求进行空指针判断，防止NPE。 5） 对于Session中获取的数据，建议NPE检查，避免空指针。 6） 级联调用obj.getA().getB().getC()；一连串调用，易产生NPE。
正例：可以使用JDK8的Optional类来防止NPE问题。


DO（Data Object）：与数据库表结构一一对应，通过DAO层向上传输数据源对象。
 DTO（Data Transfer Object）：数据传输对象，Service和Manager向外传输的对象。
 BO（Business Object）：业务对象。可以由Service层输出的封装业务逻辑的对象。
 Query：数据查询对象，各层接收上层的查询请求。注：超过2个参数的查询封装，禁止使用Map类来传输。
 VO（View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。
