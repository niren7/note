# sql


## sql

`SELECT IFNULL((SELECT MAX(GROUP_ID) FROM rc_car_base_data) + 1,1)`

取最大值加1


## 超过3个表禁止join

原因：
* 优化器很弱，涉及多个表的查询，往往得不到很好的查询计划
* 执行器很弱，只有nested loop join，block nested loop join和index nested loop join

nested loop join就是分别从两个表读一行数据进行两两对比，复杂度是n^2
block nested loop join是分别从两个表读很多行数据，然后进行两两对比，复杂度也是n^2，只是少了些函数调用等overhead
index nested loop join是从第一个表读一行，然后在第二个表的索引中查找这个数据，索引是B+树索引，复杂度可以近似认为是nlogn，比上面两个好很多，这就是要保证关联字段有索引的原因
如果有hash join，就不用做这种限制了，用第一个表（小表）建hash table，第二个表在hash table中查找匹配的项，复杂度是n。缺点是hash table占的内存可能会比较大，不过也有基于磁盘的hash join，实现起来比较复杂

解决方法

* 冗余
建表的时候，就把这些列放在一个表里，比如一开始有student(id, name)，class(id, description)，student_class(student_id, class_id)三张表，这样是符合数据库范式的(第一范式，第二范式，第三范式，BC范式等)，没有任何冗余，但是马上就不符合“编程规范“了，那我们可以用一张大表代替它，student_class_full(student_id, class_id, name, description)，这样name和description可能要被存储多份，但是由于不需要join了，查询的性能就可以提高很多了。
* 用其他方式代替
业务表join用户表，连姓名一起返回；
分两次select，第一次取得user_id，第二次取姓名；
同上，但用户保存在另一个库中，此时无法直接join或效率较低，必须分两次select；
用户保存在缓存中（如redis），缓存可以使用主动式（用户修改时更新缓存）或被动式（用户修改时删除缓存，被读取时才加载）；
从独立的用户API接口进行读取。


## 需要join的列类型要保持一致

JOIN列的类型定义最好是完全一致，包括长度，字符集，否则可能无法使用索引

* 当被驱动表的列是字符串类型，而 **驱动表** 的列类型是非字符串时，则会发生类型隐式转换，无法使用索引；
* 当被驱动表和驱动表的列都是字符串类型，两边无论是 CHAR 还是 VARCHAR，均不会发生类型隐式转换，都可以使用索引；
* 当被驱动表的列是字符串且其字符集比驱动表的列采用的字符集更小或无法被包含时（latin比utf8mb4小，gb2312 比 utf8mb4 小，另外 gb2312 虽然比 latin1 大，但并不兼容，也不行，详见下方测试 ），则会发生类型隐式转换，无法使用索引；

## 禁止左模糊

如果左边的值未确定，则不能使用索引

## 分页优化

## 查询条件区分度高的放前面

## 用`count(*)`来查寻行数

`count(*)`是sql标准统计行数的语法，和数据库无关

count(列名)不会统计此列未null值的行

count(distinct col) 计算该列除 NULL之外的不重复数量。
count(distinct col1, col2) 计算两列都不为null的数量

## 使用 sum()时需注意空指针问题。

当某一列的值全是 NULL时，count(col)的返回结果为 0，但 sum(col)的返回结果为NULL

## 使用 ISNULL()来判断是否为 NULL值

NULL与任何值的直接比较都为 NULL

## 尽量避免not in操作

* 结果不准确
    NULL与任何值的直接比较都为 NULL
* In的查询性能低下
    不能命中索引的

**使用Not Exists作为替代**

Exists的操作符不会返回Null，只会根据子查询中的每一行决定返回True或者False，当遇到Null值时，只会返回False，而不会由某个Null值导致整个子查询表达式为Null。

## 明确指出需要查询的字段名，不使用*



## 基本关键字

DISTINCT关键字，它必须直接放在列名的前面，

DISTINCT关键字应用于所有列而
不仅是前置它的列。

LIMIT 限制输出
LIMIT 5,5;
带一个值的LIMIT总是从第一行开始，给出的数为返回的行数。
带两个值的LIMIT可以指定从行号为第一个值的位置开始。

IS NULL子句检查具有NULL值的列。

AND在计算次序中优先级更高，用括号消除歧义

LIKE
% 代表任意字符
_ 代表单个字符

HAVING

REGEXP 正则匹配

|元 字 符|说 明|
| :------------- | :------------- |
|[:alnum:]| 任意字母和数字（同[a-zA-Z0-9]）|
|[:alpha:]| 任意字符（同`[a-zA-Z]`）|
|[:blank:]| 空格和制表（同`[\\t]`）|
|[:cntrl:]| ASCII控制字符（ASCII 0到31和127）|
|[:digit:]| 任意数字（同[0-9]）|
|[:graph:]| 与[:print:]相同，但不包括空格|
|[:lower:]| 任意小写字母（同[a-z]）|
|[:print:]| 任意可打印字符|
|[:punct:]| 既不在[:alnum:]又不在[:cntrl:]中的任意字符|
|[:space:]| 包括空格在内的任意空白字符（同`[\\f\\n\\r\\t\\v]`）|
|[:upper:]| 任意大写字母（同[A-Z]）|
|[:xdigit:]| 任意十六进制数字（同[a-fA-F0-9]）|


|元 字 符|说 明|
| :------------- | :------------- |
|* |0个或多个匹配|
|+ |1个或多个匹配（等于{1,}）|
|? |0个或1个匹配（等于{0,1}）|
|{n}| 指定数目的匹配|
|{n,}| 不少于指定数目的匹配|
|{n,m}| 匹配数目的范围（m不超过255）|

定位符

|元 字 符|说 明|
| :------------- | :------------- |
|^| 文本的开始|
|`$`|文本的结尾|
|`[[:<:]]`|词的开始|
|`[[:>:]]`|词的结尾|





















































































#
